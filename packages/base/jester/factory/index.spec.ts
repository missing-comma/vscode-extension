import { factoryFn as factory } from './load';
import faker from 'faker';
import { Fakeable, IJesterFactoryOptions as Options } from './domain';

const fallbackMockFn = {
	a: 1,
	b: {
		c: 2,
		d: 3,
	},
};

type FallbackMock = typeof fallbackMockFn;

const makeSut = <Raw extends Fakeable, P extends Fakeable = Raw>(
	fallback: () => Raw,
	options?: Options.Input<Raw, P>
) => {
	const sut = factory(fallback, options);

	return { sut };
};

describe('makeTestMocker Test', () => {
	test('should return an object with the default properties', () => {
		const { sut } = makeSut(() => fallbackMockFn);

		const mock = sut.one();

		expect(mock.a).toBe(1);
		expect(mock.b.c).toBe(2);
		expect(mock.b.d).toBe(3);
	});

	test('should be able to replace fallback properties', () => {
		const { sut } = makeSut(() => fallbackMockFn);

		const mock = sut.one({
			a: 5,
		});

		expect(mock.a).toBe(5);
		expect(mock.b.c).toBe(2);
		expect(mock.b.d).toBe(3);
	});

	test('should be able to replace nested fallback properties', () => {
		const { sut } = makeSut(() => fallbackMockFn);

		const mock = sut.one({
			b: { c: 6 },
		});

		expect(mock.a).toBe(1);
		expect(mock.b.c).toBe(6);
		expect(mock.b.d).toBe(3);
	});

	test('should be able to merge using custom merge function', () => {
		const { sut } = makeSut(() => fallbackMockFn, {
			mergeFn: (fallback, partial) => {
				let a = fallback.a;
				if (partial?.b && partial?.b.c) {
					a = partial?.b.c - 1;
				}
				return {
					...fallback,
					a,
				};
			},
		});

		const mock = sut.one({
			b: { c: 6 },
		});

		expect(mock.a).toBe(5);
	});

	test('two mocks generated by same function with random values in it, should not return same value', () => {
		const { sut } = makeSut(() => ({
			a: faker.datatype.number(),
		}));

		expect(sut.one().a).not.toBe(sut.one().a);
	});

	test('build should transform the generated value', () => {
		const build = jest.fn((fallback: FallbackMock) => ({ batata: fallback.a }));

		const { sut } = makeSut(() => fallbackMockFn, { build });

		const mock = sut.one();

		expect(mock).toStrictEqual({ batata: fallbackMockFn.a });
	});

	test('many should create multiple different values', () => {
		const { sut } = makeSut(() => ({
			a: faker.datatype.number(),
		}));

		const mocks = sut.many(2);

		expect(mocks.length).toBe(2);

		expect(mocks[0].a).not.toBe(mocks[1].a);
	});
});
